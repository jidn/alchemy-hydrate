import datetime
import enum
import inspect as pyinspect
import re
import types
import typing
from collections.abc import Callable

import sqlalchemy as sa
import sqlalchemy.exc
import sqlalchemy.orm as orm


def type_is_ORM(mapper: typing.Any):
    """Is mapper derived from SQLAlchemy ORM model.

    Args:
        mapper: Assumed SQLAlchemy DeclarativeBase ORM model.

    Raises:
        TypeError when mapper isn't expected type.
    """
    if not hasattr(mapper, "__table__") or not isinstance(mapper.__table__, sa.Table):
        name = getattr(mapper, "__name__", repr(mapper))
        tablename = getattr(mapper, "__tablename__", "?")
        raise TypeError(
            f"Expected a SQLAlchemy ORM model class with __table__ attribute. "
            f"Got {name} (tablename={tablename})."
        )


_M = typing.TypeVar("_M", bound=typing.Any)


class BrokenRelationshipError(RuntimeError):
    """Raised when Make hits an unresolved SQLAlchemy relationship target."""

    def __init__(
        self,
        mapper: type,
        factory: str,
        expression: str,
        original: sqlalchemy.exc.InvalidRequestError,
    ) -> None:
        self.mapper = mapper
        self.expression = expression
        self.original = original

        msg = (
            f"{factory}: unable to resolve relationship target {expression!r}. "
            "This usually means a string-based relationship() refers to a model "
            "that is not imported/defined in this test or application context."
        )

        # Put both message and expression into args for easy access
        super().__init__(msg, expression)


def _extract_unknown_relationship_expression(
    exc: sqlalchemy.exc.InvalidRequestError,
) -> str | None:
    """Try to pull the unresolved relationship expression from SQLAlchemy error.

    Handles messages like:
        'When initializing mapper Mapper[Foo(foo)], expression '
        "'Bar' failed to locate a name ('Bar'). ..."

    Returns:
        The expression string (e.g. 'Bar') or None if no match found.
    """
    msg = str(exc)

    # Common pattern: expression 'UnknownModel' failed to locate a name
    m = re.search(r"expression '([^']+)' failed to locate a name", msg)
    if m:
        return m.group(1)

    # Fallback pattern: failed to locate a name ('UnknownModel')
    m = re.search(r"failed to locate a name \('([^']+)'\)", msg)
    if m:
        return m.group(1)

    return None


class Make(typing.Generic[_M]):
    """Make ORM instance when called or ORM dict.

    + Ignore autogenerated fields like `id` by name in __init__.
    + Optional fields are set to None if not specified.
    + Unspecified fields are inferred from their python type or enum.
    + Register type defaults.

    Example:
        class Parent(BaseTest):
            __tablename__ = "parent"
            children: Mapped[list["Child"]] = relationship(back_populates="parent")

            id: Mapped[int] = mapped_column(primary_key=True, init=False)
            name: Mapped[str]
            class Kind(enum):
                Unknown: "unknown"
                Father: "father"
                Mother: "mother"
                Guardian: "guardian"

        class Child(BaseTest):
            __tablename__ = "child"
            id: Mapped[int] = mapped_column(primary_key=True, init=False)
            name: Mapped[str]
            age: Mapped[int | None]
            parent_id: Mapped[int] = mapped_column(ForeignKey("parent.id"))
            parent: Mapped[Parent] = relationship(back_populates="children")

        parent = Make(Parent,name='')
            .register_default(Parent.Kind, lambda: Parent.Kind.Unknown)
        c = Make(Child, parent=parent())
    """

    def __init__(self, mapper: type[_M], *ignore: str, **defaults: typing.Any):
        """Initialize a factory for a SQLAlchemy model class.

        With partially defined relationships (class as string and not imported
        before calling this)) dicts can be created, but not instantiated.

        Args:
            mapper: SQLAlchemy DeclarationBase model to create instances.
            *ignore: Field names to ignore (e.g., 'id').
            **defaults: Field values applied to every created instance.
        """
        type_is_ORM(mapper)
        self.mapper: type[_M] = mapper

        # Never call sa.inspect(mapper), so we don’t force SQLAlchemy to
        # configure infered relationships.  Instead relationships are inferred
        # from type hints: anything annotated but not a table column is treated
        # as “relationship-like.”

        # Type hints (safe for forward references)
        try:
            self.hints = typing.get_type_hints(self.mapper, include_extras=True)
        except NameError:
            # Fall back when forward refs or circular imports not yet resolved
            self.hints = getattr(self.mapper, "__annotations__", {})

        # Columns based purely on __table__ (no mapper inspection)
        table = mapper.__table__
        column_keys: set[str] = {c.key for c in table.columns if c.key not in ignore}

        # Relationship-like attributes: things that are annotated but not
        # direct table columns. This avoids hitting SQLAlchemy's
        # mapper/relationship inspection, so we don't force configuration
        # of unrelated mappers (which may have unresolved string refs).
        annotated_keys: set[str] = set(self.hints.keys())
        self.relationships: set[str] = annotated_keys - column_keys

        # All attributes we may want to populate
        self.all_keys: set[str] = column_keys | self.relationships

        # Determine which attributes are *not* passed to __init__ (init=False)
        signature = pyinspect.signature(mapper.__init__)
        init_param_names = {
            p.name
            for p in signature.parameters.values()
            if p.name != "self"
            and p.kind
            in (
                pyinspect.Parameter.POSITIONAL_OR_KEYWORD,
                pyinspect.Parameter.KEYWORD_ONLY,
            )
        }

        self.no_init: set[str] = self.all_keys - init_param_names

        # Validate provided defaults
        self.defaults = defaults
        invalid = set(defaults) - self.all_keys
        if invalid:
            raise AttributeError(f"Invalid default fields: {invalid}")

        # Instance-level type defaults registry
        self.type_defaults: dict[type, Callable[[], typing.Any]] = {}

    def __call__(self, **kwargs: typing.Any) -> _M:
        """Create mapper instance from given arguments and defaults.

        Set `init=False` attributes after initialization.

        Args:
            **kwargs: ORM field values, overriding defaults if any.

        Returns:
            Instance of the mapper.
        """
        init: dict[str, typing.Any] = {}
        post: dict[str, typing.Any] = {}
        for k, v in self.dict(**kwargs).items():
            (post if k in self.no_init else init)[k] = v

        try:
            inst = self.mapper(**init)
        except sqlalchemy.exc.InvalidRequestError as exc:
            # Wrap mapper configuration errors with a clearer message
            expr = _extract_unknown_relationship_expression(exc)
            if expr is None:
                # Not exactly the error we are expecting, re-raise
                raise

            raise BrokenRelationshipError(self.mapper, self.factory_label, expr, exc)

        for k, v in post.items():
            setattr(inst, k, v)

        return inst

    def dict(self, **kwargs: typing.Any) -> dict[str, typing.Any]:
        """Create dict to create instance.

        Merge defaults, kwargs, and add None/[] for unspecified optional fields.
        Create default values for required, uspecified fields.

        Args:
            *kwargs: Give data for Table column name/value.

        Returns:
            A dict suitable for Table row instance creation.
        """
        data = self.defaults.copy()
        data.update(kwargs)

        # Try to infer type-based defaults for missing fields
        for key in self.all_keys - (self.no_init | data.keys()):
            hint = self.hints.get(key)
            if hint is not None:
                data[key] = self._default_for_type(hint)
                # print(f"_default_for_type: data[{key!r}]={data[key]!r}")
            else:
                data[key] = None  # fallback

        return data

    @property
    def factory_label(self) -> str:
        """Display-friendly name used in error messages.

        Uses the *actual* class name so subclasses are reflected too.
        Examples:
            Make(User)      -> "Make(User)"
            FancyMake(User) -> "FancyMake(User)"
        """
        return f"{type(self).__name__}({self.mapper.__name__})"

    def register_default(
        self, type_: type, factory: Callable[[], typing.Any]
    ) -> typing.Self:
        """Register a default factory specific to this mapper for a type.

        Chainable with
            maker = Make(...).register_default(...).

        Args:
            type_: The type
            factory: A callable returning the default value for type_.

        Usage:
            class Status(enum):
                Ready
                Running
                Pause
                Done
            maker = Make(Progress).register_default(Status, lambda: Status.Running)
        """
        self.type_defaults[type_] = factory
        return self

    def _default_for_type(self, tp: typing.Any) -> typing.Any:
        """Return a sensible default for a given type hint."""
        if tp is None:
            return None

        # --- Handle string annotations (from __future__ import annotations) ---
        # e.g. "Mapped[list[User]]", "list[User]", "Optional[Foo]"
        if isinstance(tp, str):
            s = tp.strip()

            # unwrap Mapped[...] when spelled as a string
            # "Mapped[list[Project]]" -> "list[Project]"
            if s.startswith("Mapped[") and s.endswith("]"):
                inner = s[len("Mapped[") : -1].strip()
                return self._default_for_type(inner)

            # list[...] default -> []
            # we don't care about the inner type for the default
            if s.startswith("list[") and s.endswith("]"):
                return []

            # Optional[...] always defaults to None
            if s.startswith("Optional[") and s.endswith("]"):
                return None

        origin = typing.get_origin(tp)
        args = typing.get_args(tp)

        # Unwrap SQLAlchemy Mapped[...]
        if origin is not None and origin is orm.Mapped:
            return self._default_for_type(args[0])

        # Handle Optional[T] or Union[..., None]
        if origin in (typing.Union, types.UnionType) and type(None) in args:
            # Optional[T]
            non_none = next(a for a in args if a is not type(None))
            return self._default_for_type(non_none)

        # --- Check for registered defaults first ---
        # print("_default_for_type tp=", tp, "origin=", origin)
        if tp in self.type_defaults:
            return self.type_defaults[tp]()

        # Common primitive defaults
        if tp is bool:
            return False
        if tp is str:
            return ""
        if tp is int:
            return 0
        if origin in (list, set, tuple):
            return tp()
        if tp in (datetime.date, datetime.datetime):
            return datetime.datetime.now()
        if tp is float:
            return 0.0

        # Enum default
        if isinstance(tp, type) and issubclass(tp, enum.Enum):
            members = list(tp)
            if not members:
                return None
            # Prefer zero-valued IntEnum member if present
            if issubclass(tp, enum.IntEnum):
                for m in members:
                    if getattr(m, "value", None) == 0:
                        return m
            # Otherwise, try to find a member explicitly named 'DEFAULT' or 'UNKNOWN'
            for m in members:
                if m.name.upper() in {"DEFAULT", "UNKNOWN"}:
                    return m
            # Fallback to first defined member
            return members[0]

        # Unknown type
        return None

    def __repr__(self):
        """Object representation."""
        if not self.defaults:
            return f"<{self.factory_label}>"
        return f"<{self.factory_label} defaults={self.defaults}"
