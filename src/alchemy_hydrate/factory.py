import inspect as pyinspect
from typing import Any, Generic, TypeVar

import sqlalchemy as sa



def type_is_ORM(mapper: Any):
    """Is mapper derived from SQLAlchemy ORM model.

    Args:
        mapper: Assumed SQLAlchemy DeclarativeBase ORM model.

    Raises:
        TypeError when mapper isn't expected type.
    """
    if not hasattr(mapper, "__table__") or not isinstance(mapper.__table__, sa.Table):
        name = getattr(mapper, "__name__", repr(mapper))
        tablename = getattr(mapper, "__tablename__", "?")
        raise TypeError(
            f"Expected a SQLAlchemy ORM model class with __table__ attribute. "
            f"Got {name} (tablename={tablename})."
        )


_M = TypeVar("_M", bound=Any)
class Make(Generic[_M]):
    """Make ORM instance when called or ORM dict.

    + Ignore autogenerated fields like `id` by name in __init__.
    + Default required field values are given in __init__.
    + Optional fields are set to None if not specified.
    + Unspecified list relationships default to empty list.

    Example:
        class Parent(BaseTest):
            __tablename__ = "parent"
            id: Mapped[int] = mapped_column(primary_key=True, init=False)
            name: Mapped[str]
            children: Mapped[list["Child"]] = relationship(back_populates="parent")

        class Child(BaseTest):
            __tablename__ = "child"
            id: Mapped[int] = mapped_column(primary_key=True, init=False)
            name: Mapped[str]
            age: Mapped[int | None]
            parent_id: Mapped[int] = mapped_column(ForeignKey("parent.id"))
            parent: Mapped[Parent] = relationship(back_populates="children")

        # Create a user with default values; ignore `id`.
        parent = Parent(name='Dad', children=[])
        c = Make(Child, 'id', parent=parent)
        # `parent_id` is not required when relationship is given.
        parent.children = [c(name=name) for name in ('Anna','Benjamin')]
    """

    def __init__(self, mapper: type[_M], *ignore: str, **defaults: Any):
        """
        Args:
            mapper: SQLAlchemy DeclarationBase model to create instances.
            *ignore: Column names to ignore like `id` or other auto generated.
               Use mapped_column(..., init=False)
            **defaults: Default values for all instances or dict.
        """
        type_is_ORM(mapper)
        self.mapper: type[_M] = mapper
        self.required, self.optional, self.relationships, self.no_init = Make.discovery(
            mapper, *ignore
        )

        # Foreign keys for relationships
        self.relationship_fks: dict[str, set[str]] = {}
        # List relationships
        self.uselist: set[str] = set()

        insp = sa.inspect(mapper)
        for rel in insp.relationships:
            if rel.uselist:
                self.uselist.add(rel.key)
            if rel.direction.name in {"MANYTOONE", "ONETOONE"}:
                fks = {fk.name for fk in rel.local_columns}
                if fks:
                    self.relationship_fks[rel.key] = fks

        # Validate defaults
        self.defaults = defaults
        invalid = set(self.defaults) - (
            self.required | self.optional | self.relationships
        )
        if invalid:
            raise AttributeError(f"Invalid default fields: {invalid}")

    def __call__(self, **kwargs: Any) -> _M:
        """Create mapper instance from given arguments and defaults.

        Set `init=False` attributes after initialization.

        Args:
            **kwargs: ORM field values, overriding defaults if any.

        Returns:
            Instance of the mapper.
        """
        data: dict[str, Any] = {}
        post: dict[str, Any] = {}
        for k, v in self.dict(**kwargs).items():
            (post if k in self.no_init else data)[k] = v
        inst = self.mapper(**data)

        for k, v in post.items():
            setattr(inst, k, v)

        return inst

    def dict(self, **kwargs: Any) -> dict[str, Any]:
        """Merge defaults, kwargs, and add None/[] for unspecified optional fields.

        Args:
            *kwargs: Give data for Table column name/value.

        Returns:
            A dict suitable for Table row instance creation.
        """
        data = self.defaults.copy()
        data.update(kwargs)

        # Add default [] for list-like relationships if missing
        data.update(
            {
                key: []
                for key in self.uselist
                if key not in data and key not in self.no_init
            }
        )

        # Relationship foreign keys are not needed. Set to zero.
        for rel, fks in self.relationship_fks.items():
            if rel in data:
                data.update({k: 0 for k in fks})

        # Fields without data
        fields: set[str] = (self.required | self.optional | self.relationships) - (
            self.no_init | data.keys()
        )

        # Raise if missing required field
        missing = fields.difference(self.optional)
        if missing:
            raise ValueError(f"Missing required field: {', '.join(missing)}")

        # Set unspecified optional to None
        fields.difference_update(self.required)
        for name in fields:
            data[name] = None

        return data

    def __repr__(self):
        return (
            f"<mapper={self.mapper},"
            f"required={sorted(self.required)}, "
            f"optional={sorted(self.optional)}, "
            f"defaults={sorted(self.defaults.keys())}>"
        )

    @staticmethod
    def discovery(
        mapper: Any, *ignore: str
    ) -> tuple[set[str], set[str], set[str], set[str]]:
        """Return (required, optional, no_init) for columns/relationships.
        - required: non-nullable, non-PK columns (not ignored)
        - optional: nullable columns and PKs (not ignored)
        - relationships: relationship names
        - no_init: mapped attributes that are NOT in the dataclass __init__ params

        Args:
            table: DeclarativeBase or Table to analyze.
            *ignore: Field names to ignore.

        Returns:
            Tuple of required, optional, relationship, and `init=False` fields.

        Raise:
            TypeError when mapper is not SQLAlchemy ORM subclass
        """
        type_is_ORM(mapper)
        required: set[str] = set()
        optional: set[str] = set()

        subject = sa.inspect(mapper)
        # Partition the required and nullable columns.
        for col in subject.columns:
            if col.name in ignore:
                continue
            if col.primary_key or bool(col.nullable):
                # Primary keys are considered optional as DB will generate those.
                optional.add(col.name)
            else:
                required.add(col.name)

        relationships: set[str] = {r.key for r in subject.relationships}
        # All mapped attribute keys (columns + relationships)
        all_keys: set[str] = {c.key for c in subject.column_attrs} | relationships

        # Names of parameters accepted by the dataclass-generated __init__
        sig = pyinspect.signature(mapper.__init__)
        init_param_names = {
            p.name
            for p in sig.parameters.values()
            if p.name != "self"
            and p.kind
            in (
                pyinspect.Parameter.POSITIONAL_OR_KEYWORD,
                pyinspect.Parameter.KEYWORD_ONLY,
            )
        }

        no_init = all_keys - init_param_names

        return required, optional, relationships, no_init
